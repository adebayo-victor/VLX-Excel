<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>View Document</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='pdf_maker.css') }}">
  <style>
    :root{
      --accent:#2b6cb0;
      --bg:#fff;
      --muted:#6b7280;
      --success:#16a34a;
    }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:20px;background:#f7fafc;color:#0f172a}
    .card{background:var(--bg);border-radius:8px;padding:18px;max-width:980px;margin:0 auto;box-shadow:0 1px 3px rgba(15,23,42,0.06)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .title{font-weight:700}
    .controls{display:flex;gap:8px;align-items:center}
    a.btn, button {background:var(--accent);color:#fff;padding:8px 12px;border-radius:6px;text-decoration:none;border:none;cursor:pointer}
    a.ghost { background: transparent; color: var(--muted); border: 1px solid rgba(15,23,42,0.06); }
    .viewer-wrap{margin-top:14px;min-height:380px;border-radius:8px;overflow:hidden;border:1px solid rgba(15,23,42,0.04);background:#fff}
    iframe.pdf {width:100%;height:720px;border:0;display:block}

    /* processing / spinner */
    .center {display:flex;align-items:center;gap:12px}
    .spinner{width:44px;height:44px;border-radius:50%;border:4px solid rgba(59,130,246,0.14);position:relative;flex:0 0 auto}
    .spinner::after{content:"";position:absolute;inset:4px;border-radius:50%;border:4px solid transparent;border-top-color:var(--accent);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .status-text{font-weight:600}
    .small{font-size:.9rem;color:var(--muted)}
    .hidden{display:none}
    .success-ring { box-shadow:0 0 0 6px rgba(34,197,94,0.04); border-color: rgba(34,197,94,0.14) !important; }
    .meta{font-size:.95rem;color:var(--muted);margin-top:8px}
    .logo { margin-bottom: 10px; font-weight:700; color: var(--muted); }
  </style>
</head>
<body>
  <main class="card" id="root">
    <header>
      <div>
        <div class="title">Document Viewer</div>
        <div class="meta" id="docMeta">ID: {{ doc_id or 'unknown' }}</div>
      </div>

      <div class="controls">
        <a class="btn ghost" href="{{ url_for('index') }}">Back</a>
        <a id="openBtn" class="btn hidden" href="#" target="_blank" rel="noopener">Open in new tab</a>
        <a id="downloadBtn" class="btn hidden" href="#" download>Download</a>
      </div>
    </header>

    <section class="viewer-wrap" id="viewerWrap" aria-live="polite">
      {# If the server rendered a direct URL, embed it immediately #}
      {% if doc_url %}
        <iframe class="pdf" id="pdfFrame" src="{{ doc_url }}"></iframe>
      {% else %}
        <!-- Processing placeholder; client JS will poll for URL when doc_id is provided -->
        <div id="processing" class="center" style="padding:22px;">
          <div class="spinner" id="spinner" aria-hidden="true"></div>
          <div>
            <div class="status-text" id="processingText">Waiting for document…</div>
            <div class="small" id="processingSub">We'll check every 2 seconds until the document becomes available.</div>
          </div>
        </div>
      {% endif %}
    </section>

    <div id="msg" class="meta"></div>
  </main>

  <script>
    (function(){
      // Jinja-populated values (safe via tojson)
      const docUrlFromServer = {{ doc_url|tojson if (doc_url is defined) else 'null' }};
      const docId = {{ doc_id|tojson if (doc_id is defined) else 'null' }};
      // Server can pass a status endpoint prefix (e.g. "/api/doc_status/"), otherwise use default
      const STATUS_ENDPOINT_PREFIX = {{ status_endpoint_prefix|default('/api/doc_status/')|tojson }};

      // Elements
      const openBtn = document.getElementById('openBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const processing = document.getElementById('processing');
      const processingText = document.getElementById('processingText');
      const processingSub = document.getElementById('processingSub');
      const spinner = document.getElementById('spinner');
      const viewerWrap = document.getElementById('viewerWrap');
      const msg = document.getElementById('msg');

      let returnedUrl = null;
      let pollHandle = null;
      const POLL_INTERVAL = 2000; // ms
      const MAX_ATTEMPTS = 60; // stop after ~2 minutes

      function show(el){ el && el.classList.remove('hidden'); if (el) el.style.display = (el === processing) ? 'flex' : 'inline-block'; }
      function hide(el){ el && el.classList.add('hidden'); if (el) el.style.display = 'none'; }

      function setSuccessUI(url) {
        returnedUrl = url;
        // show buttons
        openBtn.href = url;
        downloadBtn.href = url;
        openBtn.classList.remove('hidden');
        downloadBtn.classList.remove('hidden');

        // add iframe if not already present
        if (!document.getElementById('pdfFrame')) {
          const iframe = document.createElement('iframe');
          iframe.id = 'pdfFrame';
          iframe.className = 'pdf';
          iframe.src = url;
          // replace the processing block with the iframe
          viewerWrap.innerHTML = '';
          viewerWrap.appendChild(iframe);
        } else {
          // update src if iframe exists
          document.getElementById('pdfFrame').src = url;
        }

        // spinner -> success look
        spinner.classList.add('success-ring');
        processingText.textContent = 'Document ready — click to open';
        processingSub.textContent = '';
        msg.textContent = '';
      }

      function setErrorUI(text) {
        msg.textContent = text;
        if (processingText) processingText.textContent = 'Failed to load document';
        if (processingSub) processingSub.textContent = '';
        if (spinner) spinner.style.opacity = '0.6';
      }

      // If we received URL in template, initialize immediately
      if (docUrlFromServer) {
        setSuccessUI(docUrlFromServer);
      } else if (docId) {
        // Start polling for the document URL
        let attempts = 0;
        if (processingText) processingText.textContent = 'Processing document…';
        if (processingSub) processingSub.textContent = 'Checking for available document...';

        pollHandle = setInterval(async () => {
          attempts++;
          try {
            const endpoint = STATUS_ENDPOINT_PREFIX + encodeURIComponent(docId);
            const resp = await fetch(endpoint, { method: 'GET', headers: { 'Accept': 'application/json' }});
            if (!resp.ok) {
              // If 404 keep polling (document not yet ready). For other errors show message.
              if (resp.status !== 404) {
                const txt = await resp.text();
                throw new Error(`Server returned ${resp.status}: ${txt}`);
              }
            } else {
              const data = await resp.json();
              // Expected: {"response":"successful","url":"https://..."}
              if (data && (data.response === 'successful' || data.status === 'ok') && data.url) {
                clearInterval(pollHandle);
                setSuccessUI(data.url);
                return;
              }
            }
          } catch (err) {
            console.error('Polling error', err);
            // stop polling on unexpected errors
            clearInterval(pollHandle);
            setErrorUI('An error occurred while checking the document status.');
            return;
          }

          if (attempts >= MAX_ATTEMPTS) {
            clearInterval(pollHandle);
            setErrorUI('Document not ready yet. Please try again later.');
          }
        }, POLL_INTERVAL);
      } else {
        // Nothing to do: no doc_id or doc_url
        if (processingText) processingText.textContent = 'No document specified';
        if (processingSub) processingSub.textContent = '';
        msg.textContent = 'This view expects either a doc_url or a doc_id to poll for the generated file.';
      }

      // clicking the viewer area opens the url if available
      viewerWrap.addEventListener('click', (e) => {
        if (returnedUrl) window.open(returnedUrl, '_blank', 'noopener');
      });

      // allow keyboard "o" to open if ready (accessibility)
      document.addEventListener('keydown', (e) => {
        if ((e.key === 'o' || e.key === 'O') && returnedUrl) {
          window.open(returnedUrl, '_blank', 'noopener');
        }
      });

      // Cleanup when leaving the page
      window.addEventListener('beforeunload', () => {
        if (pollHandle) clearInterval(pollHandle);
      });

    })();
  </script>
</body>
</html>